<?php
// $Id$

/**
 * @file
 * Blink client linking module
 *
 * Blink provides an interface with API (both local and XML-RPC) for managing local
 * keyword links inserted into body text.
 * This provides a foundation for integrating with a local or remotely maintained link building
 * campaign
 */

define('BLINK_VERSION', '1.1d');

if (!function_exists('db_fetch_array')) {
  function db_fetch_array($query) {
    if (is_object($query)) return $query->fetchAssoc();
  }
}
if (!function_exists('db_value')) {
  function db_value($query) {
    if (is_object($query)) return $query->fetchField();
  }
}


/**
 * Implements hook_help() ().
 */
function blink_help($path, $arg) {
  switch ($path) {
    case 'admin/help#blink':
      $output = '<p>' . t('The <em>Blink</em> module provides random keyword linking using a weighted distribution.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_menu().
 */
function blink_menu() {
 
  $items['admin/config/development/blink'] = array(
    'title' => 'Blink',
    'description' => 'Blink Link Manager',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('blink_admin_settings_form', NULL),
    'access callback' => 'user_access',
    'file' => 'blink_admin.inc',
    'access arguments' => array('administer site configuration'),
    'weight' => -20,
  );
  $items['admin/config/development/blink/settings'] = array(
    'title' => 'Settings',
    'description' => 'Link Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('blink_admin_settings_form', NULL),
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'file' => 'blink_admin.inc',
    'type'     => MENU_LOCAL_TASK,
    'weight' => -10,
  ); 
  $items['admin/config/development/blink/report'] = array(
    'title' => 'Report',
    'description' => 'Links Report',
    'page callback' => 'blink_link_report',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'file' => 'blink_admin.inc',
    'type'     => MENU_LOCAL_TASK,
    'weight' => -5,
  );
  /*
  $items['admin/config/blink/update'] = array(
    'title' => 'Request Update',
    'description' => 'Request Update Now',
    'page callback' => 'blink_force_update_now',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'file' => 'blink_admin.inc',
    'type'     => MENU_LOCAL_TASK,
    'weight' => -5,
  ); 
  
   $items['admin/config/blink/update'] = array( 
    'page callback' => 'blink_force_update_now',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'file' => 'blink_admin.inc',
    'type'  => MENU_CALLBACK, 
  );*/
  
  $items['blink/blocks'] = array(
    'page callback' => 'blink_block_page',
    'access callback' => TRUE,
    'title' => 'Blink Blocks',
  );
    
  return $items;
}
 

/**
 * Simple page function to explain what the block example is about.
 */
function blink_block_page() {
  $page = array(
    '#type' => 'markup',
    '#markup' => t('The Blink block example provides two sample blocks which demonstrate the blink linking API. The first block displays a simple link cloud of best (highest weighted) links in the system. The second displays the highest weighted links matching a particular node (for a "top search terms to this page" cloud).  To experiment with the blocks, enable and configure them on <a href="@url">the block admin page</a>.', array('@url' => url('admin/structure/block'))),
  );
  return $page;
}

 
/**
 * Implements hook_cron().
 */
function blink_cron() {

  // check for goal updates via XML-RPC
  blink_check_updates_crontask(); // cron tasks must be self-metered
}

/**
 * Implements hook_block_info().
 */
function blink_block_info() {  
  $blocks['blink_top_site_links'] = array( 
    'info' => t('Top Site Links'), 
   'cache' => DRUPAL_CACHE_GLOBAL, // default 
  ); 
  $blocks['blink_top_site_links_rand'] = array( 
    'info' => t('Randomized Top Site Links'), 
    'cache' => DRUPAL_CACHE_PER_PAGE, // default 
  );  
  $blocks['blink_page_keywords'] = array( 
    'info' => t('Top Page Keywords'), 
    'cache' => DRUPAL_CACHE_PER_PAGE, // default
    //'cache' => DRUPAL_NO_CACHE, // default 
    'pages' => 'node/*',  
  ); 
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function blink_block_view($delta) {  
  switch ($delta) { 
    case 'blink_top_site_links': 
      $kwcount = variable_get('blink_top_site_links_count', 50);
      $minsize = variable_get('blink_top_site_links_min', 8);
      $maxsize = variable_get('blink_top_site_links_max', 16); 
      $block['subject'] = t('Top Site Links'); 
      $goals = blink_top_links($kwcount); 
      if ($goals) $cloud_items = blink_goals_tagcloud($goals, $minsize, $maxsize, FALSE); 
      if (count($cloud_items))  $block['content'] = implode(' ', $cloud_items);
       else $block['content'] = " No Links Found ";
      break;
    case 'blink_top_site_links_rand':
      $kwcount = variable_get('blink_top_site_links_rand_count', 50);
      $minsize = variable_get('blink_top_site_links_rand_min', 8);
      $maxsize = variable_get('blink_top_site_links_rand_max', 16); 
      $block['subject'] = t('Top Site Links - Randomized and Page Cached'); 
      $goals_old = blink_top_links($kwcount * 3); 
      $keys = array_keys($goals_old); 
      shuffle($keys);
      $goals = array();
      foreach ($keys as $key) if (count($goals) < $kwcount) $goals[] = $goals_old[$key];  
      if ($goals) $cloud_items = blink_goals_tagcloud($goals, $minsize, $maxsize, FALSE);  
      if (count($cloud_items))  $block['content'] = implode(' ', $cloud_items);
       else $block['content'] = " No Links Found ";
      break;  
    case 'blink_page_keywords': 
      $kwcount = variable_get('blink_page_keywords_count', 50);
      $minsize = variable_get('blink_page_keywords_min', 8);
      $maxsize = variable_get('blink_page_keywords_max', 16); 
      $nid = (int) arg(1);
      $block['subject'] = t('Top Page Search Keywords');   
      $url = url('node/' . $nid, array('absolute' => TRUE));
      $goals = blink_top_links($kwcount, $url); 
      if ($goals) $cloud_items = blink_goals_tagcloud($goals, $minsize, $maxsize, TRUE); 
      if (count($cloud_items))  $block['content'] = implode(' ', $cloud_items);
        else $block['content'] = " No Keywords Found ";  
      break; 
  }
  if (isset($block)) return $block;
}

/**
 * Implements hook_block_configure().
 *
 * This hook declares configuration options for blocks provided by this module.
 */
function blink_block_configure($delta = '') { 
  $form = array();
  if ($delta == 'blink_top_site_links') { 
    $form['blink_top_site_links_count'] = array(
      '#type' => 'textfield',
      '#title' => t('Number of links to display'),
      '#size' => 20,
      '#description' => t('How many links should this block display?'),
      '#default_value' => variable_get('blink_top_site_links_count',  50),
    );
    $form['blink_top_site_links_min'] = array(
      '#type' => 'textfield',
      '#title' => t('Minimum Size in Pixels'),
      '#size' => 20, 
      '#default_value' => variable_get('blink_top_site_links_min',  10),
    );
    $form['blink_top_site_links_max'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximum Size in Pixels'),
      '#size' => 20, 
      '#default_value' => variable_get('blink_top_site_links_max',  24),
    );  
  }
  if ($delta == 'blink_top_site_links_rand') { 
    $form['blink_top_site_links_rand_count'] = array(
      '#type' => 'textfield',
      '#title' => t('Number of links to display'),
      '#size' => 20,
      '#description' => t('How many links should this block display?'),
      '#default_value' => variable_get('blink_top_site_links_rand_count',  50),
    );
    $form['blink_top_site_links_rand_min'] = array(
      '#type' => 'textfield',
      '#title' => t('Minimum Size in Pixels'),
      '#size' => 20, 
      '#default_value' => variable_get('blink_top_site_links_rand_min',  10),
    );
    $form['blink_top_site_links_rand_max'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximum Size in Pixels'),
      '#size' => 20, 
      '#default_value' => variable_get('blink_top_site_links_rand_max',  24),
    );  
  }
  if ($delta == 'blink_page_keywords') { 
    $form['blink_page_keywords_count'] = array(
      '#type' => 'textfield',
      '#title' => t('Number of links to display'),
      '#size' => 20,
      '#description' => t('How many links should this block display?'),
      '#default_value' => variable_get('blink_page_keywords_count',  50),
    );
    $form['blink_page_keywords_min'] = array(
      '#type' => 'textfield',
      '#title' => t('Minimum Size in Pixels'),
      '#size' => 20, 
      '#default_value' => variable_get('blink_page_keywords_min',  10),
    );
    $form['blink_page_keywords_max'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximum Size in Pixels'),
      '#size' => 20, 
      '#default_value' => variable_get('blink_page_keywords_max',  24),
    );  
  }
  
  return $form;
}

/**
 * Implements hook_block_save().
 *
 * This hook declares how the configured options for a block
 * provided by this module are saved.
 */
function blink_block_save($delta = '', $edit = array()) {  
  if ($delta == 'blink_top_site_links') { 
    $kwcount = $edit['blink_top_site_links_count'];
    if ($kwcount < 1) $kwcount = 1; if ($kwcount > 300) $kwcount = 300;
    $min = $edit['blink_top_site_links_min'];
    if ($min < 5) $min = 5; if ($min > 50) $min = 50;
    $max = $edit['blink_top_site_links_max']; 
    if ($max < 10) $max = 10; if ($max > 100) $max = 100;
    if ($max < $min) $max = $min; 
    variable_set('blink_top_site_links_count', $kwcount);
    variable_set('blink_top_site_links_min', $min);
    variable_set('blink_top_site_links_max', $max);
  }
  if ($delta == 'blink_top_site_links_rand') { 
    $kwcount = $edit['blink_top_site_links_rand_count'];
    if ($kwcount < 1) $kwcount = 1; if ($kwcount > 300) $kwcount = 300;
    $min = $edit['blink_top_site_links_rand_min'];
    if ($min < 5) $min = 5; if ($min > 50) $min = 50;
    $max = $edit['blink_top_site_links_rand_max']; 
    if ($max < 10) $max = 10; if ($max > 100) $max = 100;
    if ($max < $min) $max = $min; 
    variable_set('blink_top_site_links_rand_count', $kwcount);
    variable_set('blink_top_site_links_rand_min', $min);
    variable_set('blink_top_site_links_rand_max', $max);
  }
  if ($delta == 'blink_page_keywords') { 
    $kwcount = $edit['blink_page_keywords_count'];
    if ($kwcount < 1) $kwcount = 1; if ($kwcount > 300) $kwcount = 300;
    $min = $edit['blink_page_keywords_min'];
    if ($min < 5) $min = 5; if ($min > 50) $min = 50;
    $max = $edit['blink_page_keywords_max']; 
    if ($max < 10) $max = 10; if ($max > 100) $max = 100;
    if ($max < $min) $max = $min; 
    variable_set('blink_page_keywords_count', $kwcount);
    variable_set('blink_page_keywords_min', $min);
    variable_set('blink_page_keywords_max', $max);
  } 
  return;
}

/**
 * Implements hook_filter_info().
 *
 * Input filter for adding blink links to nodes
 */
function blink_filter_info() {
  $filters = array();
  $filters['blink_links'] = array(
    'title'      => t('Blink Link Filter'),
    'desription' => t('This filter will add text links to match the blink goals.'),
    'process callback' => '_blink_markup_filter',
  );
  return $filters;
}

function _blink_markup_filter($text, $filter, $format) { 
  if (!$nid = (int) arg(1)) return;
  $node = node_load($nid);
  if (blink_node_selected_for_markup($node)) { 
    if ($css_file = variable_get('blink_link_css_filepath', '')) drupal_add_css($css_file, 'file'); 
    if ($new_text = blink_markup_text($text, $nid, TRUE)) $text = $new_text; 
  }
  return $text;
}

 
/**
 * Implements hook_node_delete().
 */
function blink_node_delete($node) { 
  /* db_query("DELETE FROM {blink_links} WHERE nid = %d", $node->nid) */
  db_delete('blink_links')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_node_update(). ??
 */
function blink_node_update($node) {
  cache_clear_all("blink_page_{$node->nid}", 'cache_page');
}

  
/*
 * Loop through servers and check for updates if sufficient time has elapsed
 * Each check: every hour
 * Unregistered XML-RPC update: 4 hours
 * Registred XML-RPC update: 2 days
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function blink_check_updates_crontask() {
  if (variable_get('blink_last_check_updates', 0) < strtotime('1 hour ago')) {
    $servers = db_query("SELECT * FROM {blink_servers}");
    while ($server = db_fetch_array($servers)) {
      $do_update = FALSE;
      if (!isset($server['last_updated'])) $server['last_updated'] = 0;
      switch ($server['status']) {
        case 'unregistered':
          $do_update = (strtotime('5 minutes ago') > $server['last_updated']);
          break;
        case 'pending_approval':
          $do_update = (strtotime('2 hours ago') > $server['last_updated']);
          break;
        case 'successful_update':
          $do_update = (strtotime('2 days ago') > $server['last_updated']);
          break;
        case 'failed_update':
          $do_update = (strtotime('6 hours ago') > $server['last_updated']);
          break;
      }
      if ($do_update) {
        include_once('blink_update.inc');
        xmlc_blink_update_goals($server, BLINK_VERSION);
      }
    }
    variable_set('blink_last_check_updates', REQUEST_TIME);
  }
}

/*
 *  BLINK API - for external modules adding and removing goals
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function blink_get_keyword_goals($goal_source) {
  $result = array();
  if ($query = db_query('SELECT * FROM {blink_goals} WHERE goal_source = :goal_source', array(':goal_source' => $goal_source))) {
    while ($row = db_fetch_array($query)) $result[] = $row; 
  } 
  return $result;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function blink_delete_keyword_goal($goal, $goal_source) {
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query('DELETE FROM {blink_goals} WHERE gid=%d AND goal_source="%s"', $goal['gid'], $goal_source) */
  db_delete('blink_goals')->condition('gid', $goal['gid'])->condition('goal_source', $goal_source)->execute();
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function blink_update_keyword_goal($goal, $goal_source) {
  drupal_write_record('blink_goals', $goal, 'gid');
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function blink_add_keyword_goal($phrase, $page, $weight, $goal_source) {
  if (!(int) $weight || !trim($phrase) || !trim($page) || !trim($goal_source))  return FALSE; 
  $goal['kw'] = trim($phrase);
  $goal['url'] = is_integer($page) ? url('node/' . $page, array('absolute' => TRUE)) : $page;
  $goal['weight'] = (int) $weight;
  $goal['blsid'] = $blsid ? $blsid : db_query('SELECT blsid FROM {blink_servers} WHERE server = :server', array(':server' => "local"))->fetchField();

  // finally, add or update the modified record
  $goal['url'] = trim(url($goal['url'], array('absolute')), '/');
  $goal['goal_updated'] = REQUEST_TIME;
  $goal['goal_source'] = $goal_source;
  $goal['goal_uid'] = uniqid('b', TRUE);

  // where is local weight calculated?
  drupal_write_record('blink_goals', $goal);
}

function blink_markup_text($text, $nid = 0, $record_links = FALSE) {
  include_once('blink_markup.inc');
  return blink_filter_keywords($text, $nid, $record_links);
}
 
// returns one keyword goal from the top picks 
function blink_top_goals_random($top_range=20, $count=1, $url='') {
  $list = blink_top_links($top_range, $url);  
  shuffle($list);  
  if ($count==1) return $list[0];
  foreach ($list as $goal) {
    $result[] = $goal;
    if (count($result) >= $count) break;    
  } 
  return $result;  
}
  
// use $url to get top links for one page, otherwise, for the site
function blink_top_links($count=20, $url = '') {
  // API, wraps around internal fetch of weighted goals
  include_once('blink_markup.inc');   
  $goals = blink_weighted_goals($count, $url);    
  return $goals;
}

function blink_goals_tagcloud($goals, $minpx=6, $maxpx=15, $striplinks=FALSE) {
  // given a set of goals, returns an array of HTML items in spans with font-size between minpx and maxpx
  if (!is_array($goals)) return;
  foreach ($goals as $goal) { 
    //drupal_set_message("<pre>".print_r($goal, true)."</pre>"); return;
    $kw = $goal['kw'];
    $tags[$kw] = $goal['weight_local']; 
    $tagcount[$kw] = $goal['weight_local'];
    $urls[$kw] = $goal['url'];
  }  
  
  //drupal_set_message("blink_goals_tagcloud before smooth <pre>".print_r($tags, TRUE)."</pre>");
  $tags = _blink_pare_curve($tags, $minpx, $maxpx); 
  //drupal_set_message("blink_goals_tagcloud after smooth <pre>".print_r($tags, TRUE)."</pre>");
    
  foreach($tags as $kw => $newsize) {
    if ($striplinks) {
     $result[] = '<span class="blink_tag" style="font-size: ' . ceil($newsize) .'px" title="' . $kw . '">' . $kw . '</span>';  
    }
    else {
     $result[] = l($kw, $urls[$kw], array('attributes' => array('class' => 'blink_tag', 'style' => 'font-size: ' . ceil($newsize) .'px'))); 
    } 
  } 
  return $result;
}

function _blink_pare_curve($weights, $minsize, $maxsize) { 
 // for creating a smooth tag cloud
 // takes a set of weights and spreads them evenly over a curve from min to max
 // should produce an even gradiation despite uneven initial distribution
 // which prevents a few large tags and mostly unreadable tags
 
  $logweights = array(); // array of log value of counts
  $output = array(); // output array of linearized count values
  // Convert each weight to its log value.
  foreach ($weights AS $tagname => $w) {
    // take each weight from input, convert to log, put into new array called logweights
    $logweights[$tagname] = log($w);
  }
   
  // MAX AND MIN OF logweights ARRAY
  $max = max(array_values($logweights));
  $min = min(array_values($logweights));

  foreach($logweights AS $lw) {     
    if($lw < $min) $min = $lw;    
    if($lw > $max) $max = $lw; 
   }
   
  // Now calculate the slope of a straight line, from min to max.
  if($max > $min) $slope = ($maxsize - $minsize) / ($max - $min); 

  $middle = ($minsize + $maxsize) / 2;

  foreach($logweights AS $tagname => $w) {
    if($max <= $min) {     //With max=min all tags have the same weight.     
      $output[$tagname] = $middle;    
    }    
    else { // Calculate the distance from the minimum for this weight.     
      $distance = $w - $min; //C alculate the position on the slope for this distance.      
      $result = $slope * $distance + $minsize; // If the tag turned out too small, set minsize.         
      if( $result < $minsize) $result = $minsize;  // If the tag turned out too big, set maxsize.     
      if( $result > $maxsize) $result = $maxsize; 
      $output[$tagname] = $result;
    }
  }
  return $output;
}

// TODO: check the node against exclusion list (node types and pattern)
function blink_node_selected_for_markup($node) {
  $deselected_types = variable_get('blink_exclude_types', array());
  if (is_array($deselected_types) && in_array($node->type, $deselected_types)) return FALSE;
  
  // TODO: return FALSE if path matches exclusion path list

  //drupal_set_message("This '{$node->type}' node is being marked up");
  return TRUE;
}
